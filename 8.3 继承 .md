#### 一. 继承

> `继承` 很多面向对象的语言一般都会支持两种继承：**接口继承**和**实现继承** ，前者只继承`方法签名`(由两部分构成 ：方法名称和方法参数) ；后者继承实际的方法。

> `实现继承`是ES唯一支持的继承方法，主要是靠原型链实现的！！！ES不支持接口继承，因为ES中函数没有方法签名！！！

##### <1> 原型链

###### (1) 原型链

> `原型链`实例对象中有一个属性指向其原型对象 A ，而如果该原型对象A 同时也是原型对象 B 的实例.... 那么实例与原型 A 和 原型 B .... 之间就形成了一条原型链！！！

- 所有原型链都终于`Object`的原型 null ，因为所有函数的默认原型都是一个 **object实例**，而该object实例的原型是 Object ，Object的原型是 null

###### (2) 原型与实例之间的关系确定

- instanceof      

             - 实例a  instanceof   原型b

- isProtoTypeOf()

             - 原型b.isProtoTypeOf(实例)  

###### (3) 原型链的问题/缺点

- 原型中包含引用值的属性会在所有实例中共享

- 子类型在实例化时不能向父类型的构造函数中传参！！！

#### 二. 继承的几种形式

##### <1> 盗用构造函数    /   "对象伪装" "对象继承"

> `基本思路` 是在子类构造函数中调用父类构造函数【用 .call() or .apply() 方法】

**补充： .call()  .apply()**

           - 用法 ---  fn.call( obj , 1 , 2....)
           - 作用：
                 - 让函数立即执行
                 - 改变 this 指向
                 - 实现继承问题，在子类构造函数中调用父类型的构造函数！！！  

**优点：**

- 解决了原型链中的实例共享原型的引用值属性问题！！！【因为是用构造函数 new 出来的实例，且也调用了父类型的构造函数，那么此时原型的属性都成了实例自己的属性！！】

**缺点：**

- 函数方法不能重用，因为是在构造函数中的写的方法，所以每次调用构造函数都相当于重新创建了一次函数方法对象！！

- 子类型不能使用父类型原型上的方法！！！

##### <2> 组合继承     （伪经典继承)   原型链+盗用构造函数

> `组合继承` 综合了原型链和构造函数！！！将两者的优点结合了起来。

> `基本思路` 是使用`原型链`继承原型上的属性和方法，使用`盗用构造函数`继承实例自己的属性！！！

**是使用最多的继承方式！！！**

**缺点：**

- 效率问题，父类构造函数被调用了两次！！！

##### <3> 原型式继承

> `基本思路` 是如果想继承对象 A ，创建一个构造函数，把该构造函数的原型指向 A ，再用该构造函数 new 出来一个 实例对象 B  ，即 B 的原型是 A

`

function  fn( A ) {

function  F( ) { }

F.prototype = A；

return new F()

}

`

**特点：**

- 主要关注对象

- 不在乎类型和构造函数

**缺点：**

- 跟使用原型链一样，原型中包含引用值的属性会在实例间共享

**适用场景：**

- 已经有一个对象，想在该对象的基础上再创建一个新对象！！！

##### <4> 寄生式继承

> `基本思路` 类似于寄生构造函数和工厂模式：创建一个实现继承的函数，在函数中先拷贝源对象，然后增强副本，然后返回新对象！！

`

function  cloneObj( obj ){

克隆 obj;

增强：添加属性、方法

返回新对象；

}

`

**特点：**

- 主要关注对象

- 不在乎类型和构造函数

**缺点：**

- 函数难以重用（与构造函数相似）！！！

##### <5> 寄生式组合继承

> `基本思路` **(1)父类方法继承：** **不通过调用父类构造函数给子类原型赋值**，而是获得父类原型的一个副本，就是用`寄生式继承`来继承父类原型，然后将返回的新对象赋值给子类的原型。(即把子类的原型指向父类的原型) **(2) 父类属性继承：**`盗用构造函数`来继承父类的属性！！！

`

function  fn( subType , superType){

let prototype = object( superType.prototype ) ;  // 获得父类原型的副本

prototype.constructor = subType;

subType.prototype = prototype

}

`


