#### 一. 变量

> `变量` 分为**原始值**( null 、undefined 、boolean 、number 、string 、symbol)和**引用值**

##### (1) 变量的复制问题

- 原始值的复制：会直接把原始值的值复制一份，给新的变量，即两个变量完全独立，没有关系。

- 引用值的复制：会把该引用值储存的地址复制一份，给新的变量，即两个变量指向同一片地址，即指向同一个对象！！！

##### (2) 参数的传递

> 虽然变量的访问，有按值访问，也有按引用访问，但是参数的传递都是按值传递的！！

- 如果在函数内部，修改了参数的地址指向，如下：

`let per = new Object();

per.name = "yhx";

function  fn(obj){

obj = new Object();

obj.name = "mjq";

}

fn(per);

console.log(per.name)   //  "yhx"

`

##### (3) 引用值(对象)的类型

- typeof 用于检测原始值的类型十分有用，但是对于引用值的检测却没什么用，只会返回 "Object"

- 所以要用 `instanceof` ，后面跟上具体类型，如果是就返回 true ，不是返回 false
  
                  - 注意：instanceof后面如果是原始值，那么永远返回 `false`
                  - 如果是Object，那么永远返回 `true`

#### 二. 执行上下文与作用域

> `执行上下文` 包括**全局上下文**和**函数上下文** ，每个上下文都有一个关联的变量对象，该上下文中定义的所有函数和变量都会储存在该变量对象中。

- 在浏览器中全局上下文的变量对象为 ：window对象
  
           - 通过 var 定义的函数和变量都会成为最接近的上下文对象的属性(不一定是全局上下文中的window对象)

- 函数上下文的变量函数为 ：arguments

##### (1) 作用域链

> 上下文代码在执行时会创建一个变量对象的`作用域链`。其决定了各级上下文的代码在访问函数和变量时的顺序！！！

**注意：**

全局上下文的变量对象始终是作用域链的最后一个变量对象！！！

- 每个上下文都可以到上一级上下文变量对象中查找函数和变量，但不能到下级中查找！！！

##### （2）作用域链增强

> 有些语句(以下两种情况)会导致在作用域链的`最前端`加上一个临时上下文的变量对象，该上下文会在语句执行完毕后被删除！！！

###### <1> try / catch 的catch块

会创建一个新的变量对象，包括要抛出的错误对象的声明

###### <2> with(obj) 语句

会在最前端加上指定的对象，方便在with语句块中使用！！！



#### 三. 垃圾回收 ---- 周期性的

> 垃圾回收程序会每隔一段时间自动运行。

在垃圾回收程序运行时，如何分辨出哪些变量是要清理掉呢？就要采用标记策略，主要有两种：`标记清理` 、`引用计数`

###### <1> 标记清理：

先标记内存中所有的变量，然后把上下文中的变量，即变量引用的变量去除标记，那么剩下还带标记的就是要清除的！！！！

###### <2> 引用计数

记下每个变量被引用的次数，如果是 0 ，就证明可以被回收了

**BUT**存在循环引用问题，即一个对象的属性引用另一个对象，而另一个对象的属性同样引用这个对象！！！这样就永远不会被回收！！！



#### 四. 性能

> 垃圾回收会影响浏览器性能：会拖慢渲染速度和帧速率！！

#### 五. 内存管理

###### (1) 手动设置 null

适用于全局上下文中，因为函数上下文中的局部变量会在执行超出作用域后自动解除引用！！！！

###### (2) 使用 let 和 const 提升性能

因为 let 和 const 声明的变量是块级作用域，其结束的要比函数作用域早，`就可能会` 尽早地让垃圾回收程序介入进行垃圾回收！！！

###### (3) 隐藏类

JS 的 V8 引擎会使用 `隐藏类` ，即如果两个实例共享同一个构造函数和原型，那么这两个实例就共享同一个`隐藏类` 。如下：

`

function Circle(){

this.title = 'xxx',

}

let c1 = new Circle();

let c2 = new Circle();

`

**注意：** `动态的添加/删除属性都会使两个实例不再共享同一个隐藏类`  如下:

c1.name = "yhx";   // 就不再共享了

**所以：** 解决办法为避免 `先创建再补充` ，在构造函数时一次性声明所有属性的值，也不要删除属性，把属性值设为 null 就行！！！

###### (4) 内存泄漏

> JS 中大部分内存泄漏问题都是不合理引用的结果！！

###### <1> 意外声明全局变量

`

function fn(){

name = 'yhx';

}

`

因为没有用 var 、let 、const ，所以name会成为到window对象属性

###### <2> 定时器回调中引用外部变量

那么只要定时器不清楚，其引用的变量就永远不会被回收

###### <3> 闭包 （跟第二种情况一样）

###### (5) 静态分配和对象池

> **浏览器决定何时进行垃圾回收的一个标准就是对象更替的速度！！！**

而由上文可知，垃圾回收会影响性能，影响渲染速度和帧速率！！所以如果频繁的进行对象更新，就会使垃圾回收的频率增大！

**所以**可以采用`对象池` 

> `对象池` ：一定数量的已经创建好的对象的集合！

- 可以向对象池请求对象，设置其属性、使用它。objPool.allocate()

- 使用完毕后再归还给对象池.         objPool.free(obj1)




