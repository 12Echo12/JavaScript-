#### 一. 函数

##### <1> 函数本质是对象

> 函数本身上是一个对象，即每个函数都是 Function 类型的实例，而 Function也有属性和方法。跟其他引用类型一样，因为函数是对象，所以函数名就是指向函数对象的指针。

##### <2> 函数定义的四种形式：

###### (1) 函数声明：

`function sum(){}`

###### (2) 函数表达式

`let sum = function(){}`

###### (3) 箭头函数

`let sum = ()=>{}`

###### (4) 使用 Function 构造函数  ---- 不推荐

`let sum = new Function(参数，函数体);`

##### <3> 箭头函数 ()=>{}

- 在箭头函数内部不能使用 arguments、super 和 new.target

- 不能用作构造函数

- 没有 prototype 属性

##### <4> 参数

###### (1) 理解参数

> ES 规定中的函数，既不关心传入的参数个数，也不关心参数的数据类型。eg: 定义函数时要接收两个参数，调用函数时，可以传入三个参数、一个参数、或者一个都不传，解释器都不会报错！！！

> `这是因为`  ES 函数的参数在内部表现为一个数组，但函数并不关心这个数组里面的元素。 **在使用非箭头函数时**，可以在数组内部访问 `arguments 类数组对象`，里面存储着调用函数时，传进来的所有参数！！！！

###### (2) [非]严格模式下的arguments对象

- arguments 对象的长度是由函数调用时传入的参数个数决定的，而并非是由函数定义时定义的接收参数的个数决定的！！

- 非严格模式下， **它的值始终会与对应的命名参数同步**
  
        - function(num1,num2){
            arguments[1]  = 10;
            console.log(num2)  
        }
        // 此时输出的 num2 的值是 10

- 严格模式下， **arguments的值不会影响命名参数，并且重写 arguments对象也会导致语法错误!!!**

###### (3) 参数的传递 ---- 值传递

- 原始值类型的参数
  
  - 是把参数的值直接复制一份，复制给参数变量

- 引用值类型的参数
  
      - 是把传入的引用值类型对象的地址值复制一份，赋值给参数变量，而不是把该引用类型对象本身传进去

###### (4) 默认参数值

在 ES6 之前，想要实现默认参数的设置，需要在函数体中检测某个参数的值是否是 undefined ，是就认为没有传这个参数，就可以给它赋值！

在 ES6 之后，可以直接在**定义函数**时的参数位置显式定义默认参数。如下：

`

function sum(num1 = 1 , num2){

}

`

**注意：**

- 在使用默认参数时，arguments 对象的值不会反映参数的默认值，它**只反映传给函数的参数**，即就算定义函数时给了默认参数值，但调用函数时没有传该参数，那么 arguments[0] 的值 **依旧是 undefined**！！！

- 假如给参数赋予的默认值是一个表达式，那么该表达式只有在 **调用该函数时，才会进行计算，并将计算的结果赋值给该参数，而并不会在定义函数时就进行计算！！**

- 默认参数作用域与暂时性死区
  
        - 默认参数会按照定义它们的顺序依次被初始化，所以后面参数的默认值可以应用前面定义的参数
      
        function sum(num1 = 1 , num2 = num1){}
      
        - 但是前面的参数的默认值不能引用后面的参数，也有 "暂时性死区" 的规则
        - 参数有自己的作用域，不能引用函数体的作用域！！！

###### (5) 参数扩展与收集

- 扩展参数：

可以使用扩展运算符 ： ...

- 收集参数：

收集参数的结果是 Array 的实例，只能作为最后一个参数

`

function  sum(num1 , ...values){

console.log(values)

}

sum(1 , 2 ,3)  // [2 , 3]

sum(1)   // []

`

###### (6) 没有重载

> ES 函数没有签名，所以没有重载，如果定义了两个同名函数，那么后定义的会覆盖掉先定义的函数！！

###### 

##### <5> 函数声明提升

- 对于`函数声明` ， JS 引擎会在执行任何代码之前，先读取函数声明，并在执行上下文中生成函数定义。

- 对于`函数表达式`，必须要等到代码执行到那一行，才会在执行上下文中生成函数定义！！！

##### <6> 函数内部

> ES6 之前，函数内部有两个特殊的对象：`arguments` 和 `this`；ES6 之后又有了 `new.target`

###### (1) arguments

前面已经讨论了 arguments 对象的用途，arguments 对象还有一个 `callee属性`，是一个指向该 arguments 对象所在函数的指针！！可以用于递归调用，**就可以使函数逻辑与函数名解耦**



`

function  dfs(n){

return n + arguments.callee(n-1)

}

`

###### (2) this

它的值在标准函数和箭头函数中不相同：

- 在标准函数中，this 引用的是把函数当成方法调用的`上下文对象`

        - 如果是在全局上下文中直接调用的，那么函数中的 this 值指向 window
        - 如果是通过 obj.sum() 调用的，那么函数中的 this 值就是 obj

- 在箭头函数中，this 的值是`箭头函数定义时所处的的上下文`



###### (3) new.target

> ES 中的函数始终可以作为构造函数来实例化出一个新对象。

ES6 中新增了检测函数是否是通过 new 调用的 new.target 属性！！

> `new.target`，在类或者函数中使用，指向用 new 调用的类或者函数！！

- 如果是普通调用，new.target 的值为 undefined

- 如果是使用 new 关键字调用的，new.target 的值为被当作构造函数调用的函数

##### <7> 函数的属性和方法

###### (1) 属性 :

每个函数都有三个属性，length 、caller 、prototype

- length 的值为函数定义时，命名参数的个数

- caller 的值为调用当前函数的函数(即该函数外部包括的函数)，如果是在全局作用域下调用的，那么 caller 的值为 null

###### (2) 方法：

apply() 、call() 、bind()

- apply() 方法接收两个参数，( this值，参数数组 )

- call() 方法接收若干个参数 , ( this值 ， 参数1 ， 参数2 ， 参数3 .....)

- bind() 方法接收一个参数，( this值 )，与上面两个不同的是，bind() 方法会创建一个新的函数实例，并将这个新的函数实例内部的 this 值指向 传进去参数！！

##### <8> 尾调用优化

###### (1) 条件

- 在严格模式下

- 外部函数的返回值是对尾调用函数的调用

- 尾调用函数执行后不需要执行额外的逻辑

- 尾调用函数不是引用外部函数作用域中自由变量的闭包！！

###### (2) 是什么？

ES6 之后，新增的一项内存管理优化机制，让 JS 引擎在满足条件时可以重用栈帧。before，有几个嵌套函数就有几个栈帧，现在只有一个。

###### (3) 优点？

对递归十分友好，递归代码，会在栈内存中，迅速产生大量栈帧！！！



##### <9> 闭包

> `闭包`本质上还是一个函数，是指那些引用了另一个函数作用域中变量的函数。



**作用域链：**

在**定义**一个函数时，会为该函数创建一个`作用域链`。预装载全局变量对象，并保存在函数内部的`[[Scope]]属性`中，这个作用域链会一直向外串起所有这个函数的包含函数的活动对象！！！

**执行上下文：**

在调用该函数时，会为该函数创建函数局部上下文，然后复制函数的`[[Scope]]属性`为其创建作用域链，并创建函数的活动对象，并将其推倒作用域链前端！！

**活动对象：**

全局上下文中的叫变量对象，函数局部上下文的叫活动对象。

eg:

`

function  compare(num1 , num2){

return 0;
}

let  result = compare(0,1) ;

`

compare函数调用代码执行过后，会为它创建一个包含 `arguments、num1 、num2`的活动对象，并把它挂在作用域链上，是该作用域链上的**第一个对象**。**第二个对象**是全局上下文的变量对象，包括 `this、result 、compare`



- 闭包会保留其包含函数(外)的作用域！！！

- 内部函数是不能访问到外部函数的 this 和 arguments 的，因为内部函数调用时，会有自己的this。

       - 可以通过在外部函数中，把外部函数的this保存在一个变量中，然后在内部函数(闭包)中使用



##### <10> 立即调用的函数表达式 IIFE

( function  sum(num){

}) ()

> 在 ES6 之前，IIFE 是个非常有效的防止变量定义外泄的方式(可以用来模拟块级作用域)，它也不会导致闭包相关的内存问题。但在 ES6 之后，就有了块级作用域，就不常用 IIFE 了！！



##### <11> 私有变量

函数外部的代码是无法直接访问函数内部定义的属性和方法的，就需要 **特权方法** 来访问！！！

- 特权方法可以使用构造函数或者原型模式通过自定义来实现，也可以使用块级模式or块级增强模式在单例对象上实现！！



 
