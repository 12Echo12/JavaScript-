#### 一. 迭代器

##### <1> 可迭代对象

> `可迭代对象` 实现了 **Iterable接口**的对象，即可以被迭代器进行迭代消费操作的对象

- 可迭代对象都会暴露一个键名为 Symbol.iterator 的属性

          - 该属性的值为迭代器工厂函数，且调用该函数会返回一个`迭代器`

-  一些内置的可迭代对象

          - 字符串
          - 数组
          - 映射 、 集合
          - arguments对象
          - NodeList 

- 实际过程中不需要显示的调用上述工厂函数，一些原生语言会自动帮我们调用！！！

           - for - of
           - 数组结构
           - 扩展符
           - Array.from()
           - 创建映射 、集合
           - yield* 操作符

##### <2> 迭代器

> `迭代器` 是按需创建的一次性对象。实现了 **Iterator接口**的结构，可以对`可迭代对象`进行迭代消费操作！！！

- 迭代器会暴露与迭代操作相关的 API

      - next()
                - 该方法会返回一个`迭代器对象 `{done:  , value: }`

- 迭代器会维持着一个对其关联的可迭代对象的引用 ，所以迭代器会组织对该可迭代对象的垃圾回收！！！

##### <3> 提前终止迭代器

**(1) return() 方法**

- return() 方法是可选的，即有些迭代器可能没有实现 return() 方法，即有些迭代器是不可关闭的，如`数组迭代器`
  
      - 不可关闭的迭代器，下次迭代会在之前的基础上继续进行
      - 可关闭的迭代器，下次迭代重新开始新的迭代！！！

- return() 方法必须返回一个 `迭代器对象`



#### 三. 生成器

##### <1> 生成器

> `生成器` 本质上是一个函数！！！在函数名称前加一个 * ，则表示该函数为一个生成器，如下：

**function  *fn() { }**

##### <2> 生成器对象

> `生成器对象` ，实现了 **Iterator接口** ，可进行迭代 。也实现了**Iterable接口** ，默认的迭代器是`自引用的`



- 有 next() 方法  ------ **让生成器开始 or 恢复执行**

         - 调用 next() 方法，会返回 `{done:  , value: }`

##### <3> yield 中断执行

> 生成器函数在遇见 yield 之前会正常执行，但在遇到了 yield 关键字后，会保留函数状态，并暂停执行。

- yield 后的值 x 会出现在 `next()方法`返回的对象中 { done : **false**  ,  value : x }

- `yield` 关键字只能在生成器中使用，



##### <4> 生成器的用处

###### (1) 把生成器对象当作可迭代的对象

`

function  * fn( ) {           -------> 生成器函数

yield  1 ;

yield  2 ;

yield  3 ;

}  

for ( const  a  of   fn() ) {

console.log( a )

}   // 1   2   3

`

###### (2) 使用 yield 关键字实现输入和输出

- 上一次让生成器函数暂停的 yield 关键字会收到传给 `next()` 方法的第一个参数！！！[ 即此时，yield 相当于一个变量来接收参数]

- yiled 后面的值 x ，会出现在调用 next( ) 方法后，返回的对象中 { done : false , value : x }

###### (3) 产生可迭代对象

使用 * 可以增强 **yield**的行为 ，即  yield* ，使它可以去迭代一个 `可迭代对象`，即可以实现在生成器函数内部，再迭代多个对象 ！！！ *yield [1 , 2 , 3 ]

###### (4) 使用 yield * 实现优雅的递归算法

##### <5> 提前终止生成器

- return( )

        - 传给 return() 方法的值 x，会出现在调用 return() 方法返回的对象中 { done : ture , value : x}

- throw( )

     - throw() 方法会把一个错误注入到生成器对象中，如果错误被捕获处理了，生成器就不会发生中断，
     会继续进行，如果未被处理，生成器函数就会中断进行！！！
     - 并且如果处理了，生成器会跳过 此时的yiled ，即会跳过一个值！！！(p204)


