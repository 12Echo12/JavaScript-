#### 一. 异步编程

> `同步行为`和`异步行为`的对立统一使计算机科学的一个基本概念，特别是在 JavaScript这种单线程事件循环模型中！！异步行为是为了优化因计算量大而时间长的操作！！！

##### <1> 同步与异步

> `同步行为` 对应内存中顺序执行的处理器指令。

> `异步行为` 类似于中断，即当前进程外部的代码可以触发代码执行。异步操作通常是必要的，比如代码要访问一些高延迟的资源，例如：要想向远端的服务器发送请求并等待响应，那么就会出现很长时间的等待！！！

- 异步代码不容易被推断，即不容易得知中断什么时候发生，即异步代码什么时候被执行？

##### <2> 以往的异步编程模式

> 以往的异步操作，只能通过使用回调函数来表明异步操作的完成，即该异步函数执行完后，自动调用该函数的回调函数(把一个函数作为参数传到另一个函数中) ，可以在回调函数中进行某些操作，来证明该异步操作已经完成！！！

**But** 由于串联多个异步操作是一个常见的问题，所以还用回调函数来表示完成状态，就会产生深度嵌套的回调函数(回调地狱)！！



#### 二. 期约 Promise

> ES6 增加了 Promise 类型，其成为了主导型的异步编程机制

##### <1> 期约的创建

- 通过 new 操作符来实现 Promise 的实例化！！！

- 构造函数中需要传入 `执行器(excuter)函数` 作为参数，执行器函数有两个函数参数resolve() 、reject() ，调用两者，可以分别实现不同的状态改变！！！

##### <2> 期约状态机

###### (1) 三种状态

期约是一个有状态的对象，其有三种状态：

- 待定 pending

- 兑现/解决 fulfilled/resolved

- 拒绝 rejected

> 待定 pending 是期约最开始的状态，期约的状态只能改变一次，只能从 pending --> resolved  或者 pending --> rejected 且状态的改变是不可逆的！！！

**注意：**

期约的状态是私有的，只能在期约内部进行操作 ，外部的 JavaScript 代码是检测不出来的！！！

###### (2) 期约的用途

- 抽象地表示一个异步操作，用自己的状态来反映异步操作的进展情况

- 某些异步操作可能会有返回值，用期约封装这些异步操作，就可以在期约状态发生改变后获得该值！！！

###### (3) 期约状态的改变   ----  通过执行函数来改变期约状态

期约状态的改变通常是在期约的两个参数（执行函数）内部实现的，两个执行函数通常命名为 resolve( ) , reject( ) ; 调用 resolve() 函数会把状态改为 兑现....

###### (4) Promise.resolve()

可以实例化一个解决的期约，且该期约的值就是传入的`第一个`参数

**eg：** console.log(Promise.resolve(3 , 4 , 5))   Promise <resolved> : 3

- 具有幂等性

**eg：**  let  p   =  Promise.resolve(3)      

console.log( Promise.resolve(p)  == p)   // true

###### (5) Promise.reject()

可以实例化一个拒绝的期约，且期约的拒绝理由就是传入的`第一个`参数

- `不`具有幂等性   , 理由就是传入的参数

###### (6) 同步异步执行的二元性

`

try{

Promise.reject( new Error("bar"))

}catch(e){

console.log(e)

}         // Uncaught....

`

可见 try/catch 同步代码并没有捕捉到期约抛出的错误，**原因如下：**

> 拒绝期约抛出的错误并没有抛到执行同步代码的线程中，而是通过浏览器异步消息队列来处理的。**代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构 --- Promise**，同步代码是与之交互不了的！！！



##### <3> 期约的实例方法

`是连接外部同步代码和内部异步代码之间的桥梁`

###### (1) Promise.prototype.then()

> 该方法接收两个参数 onresolved() 、onRejected() 两个处理程序，如果提供的话，`会在期约进入解决or拒绝状态时执行`，因为Promise状态只能改变一次，所以两个处理程序是互斥的！！！

- 两个参数都是可选的，如果只想提供 onRejected() 处理程序，那么就要在第一个参数的
  
  位置上传入 null

- 该方法返回一个新的期约实例 ===>把处理程序的返回值包装形成 ，通过 resolve() 包装！！！
  
  let p1 = Promise.resolve( " foo" )
  
         - 如果没有提供该处理程序，那么会 Promise.resolve() 会包装上一个期约解决之后的值
         - 如果没有显示的返回值，那么Promise.resolve()会包装 undefined 
                    - p1.then(()=>{})
         - Promise.resolve() 保留返回的期约
                    - p2 = p1.then(()=>new Promise()) 
                      p3 = p1.then(()=>Promise().reject())
                      // p2  Promise<pending>
                      // p3  Promise<rejected> : undefined
         - 在 onResolved() 程序种`抛出`异常or错误 返回`拒绝的期约`
                     - p4 = p1.then(()=> throw "baz")
                      // p4  Promise<rejected> : baz
         - 在 onResolved() 程序中`返回`错误值，会返回一个包装这错误信息的`已解决期约`
                      - p5 = p1.then(()=> Error 'que')
                      // p5  Promise<resolved> Error : que

**注意：**

上述是调用onResolved() 程序的返回结果，调用 onRejected() 程序的返回结果是一样的，也是通过 Promise.resolve() 方法包装！！！



###### (2) Promise.prototype.catch()

> .catch() 方法用于给期约添加期约拒绝处理程序 onRejected()，相当于一个`语法糖`，调用它就相当于调用 Promise.prototype.then(null , onRejected())

- 该方法只接收一个参数，onRejected() 处理程序

- 返回一个新的期约实例，跟上面的 Promise.prototype.then() 的 onResolved() 程序的返回处理方法是一样的

###### (3) Promise.prototype.finally()

> 该方法用于给期约添加 onFinally() 处理程序 ，该程序会在期约的状态发生改变后执行（不管是哪种改变都会执行），常常用于添加清理代码！！！

- 接收一个参数 ，onFinally() 处理程序

- 返回值 ，大多数为父期约的传递
  
         - 不是父期约传递的情况：
                    - onFinally() 处理程序返回的是待定的期约 、处理程序抛出错误 、处理程序返回拒绝的期约
                    - 上述情况，会直接返回程序返回的！！！

##### <4> 期约的"非重入"特性

> 当期约的状态发生改变后，与该状态相关的处理程序仅仅会被**排期**，而并非立即执行！！！跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前执行。 (p335)

##### <5> 临近处理程序的执行顺序

- 会按照添加的顺序来执行！！！

##### <6> 传递解决值和拒绝理由

> 在执行函数中，解决值和拒绝的理由会分别作为 resolve() 、reject() 的第一个参数，向下传，传到对应的处理程序中，作为处理程序的第一个参数，以供在处理程序中使用。

`

let p1 = new Promise( (resolve , reject )=> resolve( "foo" ) );

p1.then( (value)=>{ console.log( value ) } )    //  "foo"

`

##### <7> 拒绝期约与拒绝错误处理

> 在执行函数 or 处理程序中抛出错误，该错误都会作为一个拒绝期约的拒绝理由返回！！！

>  正常情况下，在同步代码中抛出错误 ，throw Error( 'foo' ) ，会暂停后序代码的执行。**But**在期约中抛出错误，因为错误是从消息队列中异步抛出的，所以不会阻止后续同步代码的执行

- then() 和 catch() 的 onRejected() 处理程序在语义上相当于  try / catch ，出发点都是捕获错误，返回一个`已解决的期约`！！！

##### <8> 期约连锁与期约合成

###### (1) 期约连锁

> 期约的 .then()  .catch()  .finally() 方法都会返回一个新的期约实例，而该实例也会有自己的 .then() .catch() .finally() 方法 ，so就会形成期约连锁！！！

###### (2) 期约合成

> 将多个期约实例合成一个期约实例的方法

- Promise.all()

        - 接收一个可迭代对象作为参数，可迭代对象中的元素会依次通过 Promise.resolve()转换为期约
        - 有待定  ---->  待定
        - 全解决  ---->  解决
        - 有拒绝  ---->  第一个拒绝

- Promise.race()

         - 接收一个可迭代对象作为参数
         - 合成为最先解决or拒绝的期约

##### <9> 不支持期约取消和进度通知

#### 


